{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome!","title":"Home"},{"location":"#welcome","text":"","title":"Welcome!"},{"location":"cgroups/","text":"cgroups Ubuntu 18.04 view cgroup info of process via pid ps -o cgroup 12345 create memory cgroup sudo mkdir /sys/fs/cgroup/memory/cgroup-a limit memory of anything running in the cgroup cgroup-a to 4096 bytes echo 4096 | sudo tee /sys/fs/cgroup/memory/cgroup-a/memory.limit_in_bytes add process via pid to the cgroup cgroup-a sudo echo 12345 > /sys/fs/cgroup/memory/cgroup-a/cgroup.procs using libcgroup create memory cgroup cgroup-a sudo cgcreate -g memory:cgroup-a delete memory cgroup cgroup-a sudo cgdelete memory:cgroup-a run app app-a in cgroup cgroup-a sudo cgexec -g memory:cgroup-a app-a","title":"cgroups"},{"location":"cgroups/#cgroups","text":"","title":"cgroups"},{"location":"cgroups/#ubuntu-1804","text":"view cgroup info of process via pid ps -o cgroup 12345 create memory cgroup sudo mkdir /sys/fs/cgroup/memory/cgroup-a limit memory of anything running in the cgroup cgroup-a to 4096 bytes echo 4096 | sudo tee /sys/fs/cgroup/memory/cgroup-a/memory.limit_in_bytes add process via pid to the cgroup cgroup-a sudo echo 12345 > /sys/fs/cgroup/memory/cgroup-a/cgroup.procs","title":"Ubuntu 18.04"},{"location":"cgroups/#using-libcgroup","text":"create memory cgroup cgroup-a sudo cgcreate -g memory:cgroup-a delete memory cgroup cgroup-a sudo cgdelete memory:cgroup-a run app app-a in cgroup cgroup-a sudo cgexec -g memory:cgroup-a app-a","title":"using libcgroup"},{"location":"kubernetes/","text":"Kubernetes Ubuntu 18.04 kubectl get assets kubectl get <services|deployments|nodes|pods> describe assets in more detail kubectl describe <asset> <asset name> get pods that a deployment is running on deployment=<deployment name> kubectl get pods --selector=\"$(kubectl describe deployments $deployment | grep Selector | awk '{print $2}')\" --output=wide` curl service that is exposed via NodePort service=<service name> curl $(kubectl get nodes | sed -n 2p | awk '{print $1}'):$(kubectl describe service $service | grep NodePort: | awk '{print $3}' | sed 's/\\/.*//') delete service and deployment via deployment name deployment=<deployment name> kubectl delete services $(kubectl get services --selector=$(kubectl describe deployments $deployment | grep Selector | awk '{print $2}') | sed -n 2p | awk '{print $1}') kubectl delete deployment $deployment","title":"Kubernetes"},{"location":"kubernetes/#kubernetes","text":"","title":"Kubernetes"},{"location":"kubernetes/#ubuntu-1804","text":"","title":"Ubuntu 18.04"},{"location":"kubernetes/#kubectl","text":"get assets kubectl get <services|deployments|nodes|pods> describe assets in more detail kubectl describe <asset> <asset name> get pods that a deployment is running on deployment=<deployment name> kubectl get pods --selector=\"$(kubectl describe deployments $deployment | grep Selector | awk '{print $2}')\" --output=wide` curl service that is exposed via NodePort service=<service name> curl $(kubectl get nodes | sed -n 2p | awk '{print $1}'):$(kubectl describe service $service | grep NodePort: | awk '{print $3}' | sed 's/\\/.*//') delete service and deployment via deployment name deployment=<deployment name> kubectl delete services $(kubectl get services --selector=$(kubectl describe deployments $deployment | grep Selector | awk '{print $2}') | sed -n 2p | awk '{print $1}') kubectl delete deployment $deployment","title":"kubectl"},{"location":"linux-system-calls/","text":"Linux System Calls seccomp (secure computing mode) Filter system calls issued by a program. The filters are based on BPF (Berkley Packet Filters). The idea behind seccomp is to restrict the system calls that can be made from a process, he said. The Linux kernel has a few hundred system calls, but most of them are not needed by any given process. If a process can be compromised and tricked into making other system calls, though, it may lead to a security vulnerability that could result in the compromise of the whole system. By restricting what system calls can be made, seccomp is a key component for building application sandboxes. #include <seccomp.h> /* libseccomp */ scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_KILL); // default action: kill seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(dup2), 2, SCMP_A0(SCMP_CMP_EQ, 1), SCMP_A1(SCMP_CMP_EQ, 2)); // pass dup2(1,2); //fail dup2(2, 42); dup2 Change file descriptor. // redirect stderr to stdout dup2(1, 2); prlimit Get and set process resource limits. This routine makes ULIMIT(3) obsolete. struct rlimit old, new; struct rlimit *newp; pid_t pid; new.rlim_cur = /* soft limit */ new.rlim_max = /* hard limit */ newp = &new; prlimit(pid, RLIMIT_CPU, newp, &old) /* resource options in PRLIMIT(2) */ There is also a CLI tool for prlimit in PRLIMIT(1). printk Logging mechanism for debugging kernel space code. #include <linux/kernel.h> /* Needed for KERN_ALERT */ printk(\"<0>System dead.\\n\"); from userspace $ echo \"2Writing critical printk messages from userspace\" >/dev/kmsg $ dmesg console_loglevel To determine current console_loglevel: $ cat /proc/sys/kernel/printk The output values are in respect: current default minimum boot-time-default","title":"Linux System Calls"},{"location":"linux-system-calls/#linux-system-calls","text":"","title":"Linux System Calls"},{"location":"linux-system-calls/#seccomp-secure-computing-mode","text":"Filter system calls issued by a program. The filters are based on BPF (Berkley Packet Filters). The idea behind seccomp is to restrict the system calls that can be made from a process, he said. The Linux kernel has a few hundred system calls, but most of them are not needed by any given process. If a process can be compromised and tricked into making other system calls, though, it may lead to a security vulnerability that could result in the compromise of the whole system. By restricting what system calls can be made, seccomp is a key component for building application sandboxes. #include <seccomp.h> /* libseccomp */ scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_KILL); // default action: kill seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(dup2), 2, SCMP_A0(SCMP_CMP_EQ, 1), SCMP_A1(SCMP_CMP_EQ, 2)); // pass dup2(1,2); //fail dup2(2, 42);","title":"seccomp (secure computing mode)"},{"location":"linux-system-calls/#dup2","text":"Change file descriptor. // redirect stderr to stdout dup2(1, 2);","title":"dup2"},{"location":"linux-system-calls/#prlimit","text":"Get and set process resource limits. This routine makes ULIMIT(3) obsolete. struct rlimit old, new; struct rlimit *newp; pid_t pid; new.rlim_cur = /* soft limit */ new.rlim_max = /* hard limit */ newp = &new; prlimit(pid, RLIMIT_CPU, newp, &old) /* resource options in PRLIMIT(2) */ There is also a CLI tool for prlimit in PRLIMIT(1).","title":"prlimit"},{"location":"linux-system-calls/#printk","text":"Logging mechanism for debugging kernel space code. #include <linux/kernel.h> /* Needed for KERN_ALERT */ printk(\"<0>System dead.\\n\");","title":"printk"},{"location":"linux-system-calls/#from-userspace","text":"$ echo \"2Writing critical printk messages from userspace\" >/dev/kmsg $ dmesg","title":"from userspace"},{"location":"linux-system-calls/#console_loglevel","text":"To determine current console_loglevel: $ cat /proc/sys/kernel/printk The output values are in respect: current default minimum boot-time-default","title":"console_loglevel"}]}